"use strict";(self.webpackChunklukso_docs=self.webpackChunklukso_docs||[]).push([[2570],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),s=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return i.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),u=s(n),h=a,f=u["".concat(l,".").concat(h)]||u[h]||p[h]||r;return n?i.createElement(f,o(o({ref:t},d),{},{components:n})):i.createElement(f,o({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var s=2;s<r;s++)o[s]=n[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7217:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>c,toc:()=>s});var i=n(7462),a=(n(7294),n(3905));const r={sidebar_label:"LSP20 - Call Verification",sidebar_position:6},o="LSP20 - Call Verification",c={unversionedId:"standards/generic-standards/lsp20-call-verification",id:"standards/generic-standards/lsp20-call-verification",title:"LSP20 - Call Verification",description:"LSP20 - Call Verification",source:"@site/docs/standards/generic-standards/lsp20-call-verification.md",sourceDirName:"standards/generic-standards",slug:"/standards/generic-standards/lsp20-call-verification",permalink:"/standards/generic-standards/lsp20-call-verification",draft:!1,editUrl:"https://github.com/lukso-network/docs/tree/main/docs/standards/generic-standards/lsp20-call-verification.md",tags:[],version:"current",lastUpdatedAt:1686651321,formattedLastUpdatedAt:"Jun 13, 2023",sidebarPosition:6,frontMatter:{sidebar_label:"LSP20 - Call Verification",sidebar_position:6},sidebar:"standardsSidebar",previous:{title:"LSP17 - Contract Extension",permalink:"/standards/generic-standards/lsp17-contract-extension"},next:{title:"Introduction",permalink:"/standards/universal-profile/introduction"}},l={},s=[{value:"Introduction",id:"introduction",level:2},{value:"What does this standard represent ?",id:"what-does-this-standard-represent-",level:2},{value:"Specification",id:"specification",level:2},{value:"Delegating Contract",id:"delegating-contract",level:3},{value:"Verification-receiving Contract (Logic Verifier)",id:"verification-receiving-contract-logic-verifier",level:3},{value:"Example Usage",id:"example-usage",level:3}],d={toc:s};function p(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"lsp20---call-verification"},"LSP20 - Call Verification"),(0,a.kt)("admonition",{title:"Standard Document",type:"info"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-20-CallVerification.md"},"LSP20 - Call Verification"))),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Smart contracts often have complex requirements that need to be checked before executing a function. These requirements might change over time, adding to the complexity of managing them within the same contract."),(0,a.kt)("p",null,"In order to maintain the integrity and security of smart contracts, while enhancing their ability to respond to change, a mechanism that enables a contract to delegate the verification of a function call to another contract can be extremely useful. This mechanism would not only ensure the fulfillment of varying requirements but also allow these requirements to be modified, updated, or enhanced without disrupting the primary contract's functionality."),(0,a.kt)("h2",{id:"what-does-this-standard-represent-"},"What does this standard represent ?"),(0,a.kt)("p",null,"The LSP20 standard addresses this issue by introducing a mechanism for delegating the verification of a function call to another contract. This enables the smart contract to update, modify, or enhance the requirements without affecting the primary contract's functionality, making the smart contract more versatile and adaptable."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"LSP20Verification",src:n(4412).Z,width:"2828",height:"1414"})),(0,a.kt)("h2",{id:"specification"},"Specification"),(0,a.kt)("p",null,"The LSP20 standard defines two sections, detailing the expected behavior in both the delegating contract and the verification-receiving contract."),(0,a.kt)("h3",{id:"delegating-contract"},"Delegating Contract"),(0,a.kt)("p",null,"The behavior of the delegating contract is defined in the LSP20 standard. When a function in this contract is called, it should forward the call to the ",(0,a.kt)("inlineCode",{parentName:"p"},"lsp20VerifyCall")," function implemented on the verification-receiving contract, passing the necessary arguments for verification. These arguments include:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Caller information"),(0,a.kt)("li",{parentName:"ol"},"Amount of native tokens sent (",(0,a.kt)("inlineCode",{parentName:"li"},"msg.value"),")"),(0,a.kt)("li",{parentName:"ol"},"Calldata provided by the caller (the function called and its arguments)")),(0,a.kt)("p",null,"The logic verifier contract uses these arguments to perform the verification. For example, it may have logic that checks how much LYX is sent and authorizes the call based on a minimum amount sent. Alternatively, it could verify solely based on the address of the caller, irrespective of the amount of LYX sent."),(0,a.kt)("p",null,"Once the ",(0,a.kt)("inlineCode",{parentName:"p"},"lsp20VerifyCall")," verifies and authorizes the call, an optional post-execution check can be performed through the ",(0,a.kt)("inlineCode",{parentName:"p"},"lsp20VerifyCallResult")," function. The result of the executed function gets passed to the logic verifier, which allows for checks such as balance changes or other aspects of the contract."),(0,a.kt)("h3",{id:"verification-receiving-contract-logic-verifier"},"Verification-receiving Contract (Logic Verifier)"),(0,a.kt)("p",null,"The logic verifier contract, which receives the delegation for verification, is required to implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"lsp20VerifyCall")," function, and ",(0,a.kt)("inlineCode",{parentName:"p"},"lsp20VerifyCallResult")," function if it is to be used for post-execution checks."),(0,a.kt)("p",null,"There is no standardized logic for these functions; it is up to the implementer to decide how to use them and integrate any required logic. The parameters provide context about the call's different aspects (caller, value sent, data sent), and it's up to the implementer to decide whether to allow it or not. As mentioned, the return value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"lsp20VerifyCall")," function determines whether the ",(0,a.kt)("inlineCode",{parentName:"p"},"lsp20VerifyCallResult")," should be invoked."),(0,a.kt)("h3",{id:"example-usage"},"Example Usage"),(0,a.kt)("p",null,"Imagine a smart contract that governs an online marketplace where users can buy and sell goods. Each transaction in this marketplace might require specific verification checks like verifying the availability of goods from the seller, confirming the buyer's payment ability, and potentially even checking the reputation score of both parties."),(0,a.kt)("p",null,"By leveraging the LSP20 standard, the marketplace contract can delegate these complex verification tasks to a separate logic verifier contract. In case the marketplace wants to introduce new checks in the future such as KYC status, dispute history, etc., they simply update the logic verifier contract. This decoupling of verification logic from the primary contract ensures that the marketplace contract remains agile, adaptable, and easy to manage."))}p.isMDXComponent=!0},4412:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/LSP20-Verification-7e7660f033b4fef994eaba0c48aebf6e.jpeg"}}]);